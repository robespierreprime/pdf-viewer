<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>PDF Viewer</title>
  <style>
    @font-face {
    font-family: "self-modern_regular";
    src: url("/self-modern_regular.ttf");
  }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: white;
    }
    
    #viewer-container {
      width: 100vw;
      height: 100vh;
      overflow-y: scroll;
      overflow-x: hidden;
      scroll-behavior: smooth;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    
    #viewer-container::-webkit-scrollbar {
      display: none;
    }
    
    #viewer {
      width: 100%;
      margin: 0;
      padding: 0;
    }
    
    .page-container {
      margin: 0;
      background: white;
      width: 100%;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: auto;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }
    
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #666;
      font-size: 18px;
      font-family: 'self-modern_regular';
      font-weight: 400;
      letter-spacing: 0.5px;
      background: rgba(255, 255, 255, 0.95);
      padding: 30px 50px;
      border-radius: 15px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      gap: 10px;
      transition: opacity 0.8s ease-out;
      z-index: 1000;
    }
    
    #loading.fade-out {
      opacity: 0;
    }
    
    .dots {
      display: flex;
      gap: 8px;
      align-items: center;
      height: 20px;
    }
    
    .dot {
      width: 4px;
      height: 4px;
      background-color: #666;
      border-radius: 50%;
      animation: bounce 1.2s infinite;
    }
    
    .dot:nth-child(1) {
      animation-delay: 0s;
    }
    
    .dot:nth-child(2) {
      animation-delay: 0.3s;
    }
    
    .dot:nth-child(3) {
      animation-delay: 0.6s;
    }
    
    @keyframes bounce {
      0%, 100% {
        transform: translateY(0);
      }
      25% {
        transform: translateY(-9px);
      }
      50% {
        transform: translateY(0);
      }
    }
  </style>
</head>
<body>
  <div id="loading">
    <span>chargement du pdf</span>
    <div class="dots">
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
    </div>
  </div>
  
  <div id="viewer-container">
    <div id="viewer"></div>
  </div>

  <script type="module">
  import * as pdfjsLib from './pdfjs/pdf.mjs';

  pdfjsLib.GlobalWorkerOptions.workerSrc = './pdfjs/pdf.worker.mjs';

  const url = 'src.pdf';
  let pdfDoc = null;
  let currentPage = 1;
  let pageElements = [];
  let renderedPages = new Set();

  const loadingDiv = document.getElementById('loading');
  const viewerContainer = document.getElementById('viewer-container');

  /* Device pixel ratio for high-resolution rendering */
  const pixelRatio = window.devicePixelRatio || 1;

  async function renderPage(pageNumber) {
    if (renderedPages.has(pageNumber)) return;
    
    const page = await pdfDoc.getPage(pageNumber);

    const containerWidth = viewerContainer.clientWidth;
    const viewport = page.getViewport({ scale: 1 });
    const scale = containerWidth / viewport.width;
    
    const scaledViewport = page.getViewport({ scale: scale * pixelRatio });

    const pageContainer = pageElements[pageNumber - 1];
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    canvas.width = scaledViewport.width;
    canvas.height = scaledViewport.height;
    
    canvas.style.width = `${containerWidth}px`;
    canvas.style.height = `${scaledViewport.height / pixelRatio}px`;

    await page.render({
      canvasContext: context,
      viewport: scaledViewport
    }).promise;

    pageContainer.innerHTML = '';
    pageContainer.appendChild(canvas);
    pageContainer.style.minHeight = 'auto';
    
    renderedPages.add(pageNumber);
  }

  try {
    pdfDoc = await pdfjsLib.getDocument(url).promise;

    /* Create containers for all pages */
    for (let pageNumber = 1; pageNumber <= pdfDoc.numPages; pageNumber++) {
      const pageContainer = document.createElement('div');
      pageContainer.className = 'page-container';
      pageContainer.dataset.pageNumber = pageNumber;
      
      document.getElementById('viewer').appendChild(pageContainer);
      pageElements.push(pageContainer);
    }

    /* Render first three pages */
    await renderPage(1);
    await renderPage(2);
    await renderPage(3);

    loadingDiv.classList.add('fade-out');
    
    setTimeout(() => {
      loadingDiv.style.display = 'none';
    }, 800);

    /* Render remaining pages in background */
    for (let i = 4; i <= pdfDoc.numPages; i++) {
      await renderPage(i);
    }

  } catch (error) {
    loadingDiv.innerHTML = 'Error loading PDF: ' + error.message;
    console.error('Error:', error);
  }

  function goToPage(pageNum) {
    if (!pdfDoc || pageNum < 1 || pageNum > pdfDoc.numPages) return;
    
    currentPage = pageNum;
    const pageElement = pageElements[pageNum - 1];
    pageElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }

  /* Keyboard navigation */
  document.addEventListener('keydown', (e) => {
    switch(e.key) {
      case 'ArrowDown':
      case ' ':
      case 'PageDown':
        e.preventDefault();
        goToPage(currentPage + 1);
        break;
      case 'ArrowUp':
      case 'PageUp':
        e.preventDefault();
        goToPage(currentPage - 1);
        break;
      case 'Home':
        e.preventDefault();
        goToPage(1);
        break;
      case 'End':
        e.preventDefault();
        if (pdfDoc) goToPage(pdfDoc.numPages);
        break;
    }
  });

  /* Detect currently visible page during scroll */
  let scrollTimeout;
  viewerContainer.addEventListener('scroll', () => {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
      const containerRect = viewerContainer.getBoundingClientRect();
      const containerCenter = containerRect.top + containerRect.height / 2;
      
      for (let i = 0; i < pageElements.length; i++) {
        const pageRect = pageElements[i].getBoundingClientRect();
        if (pageRect.top <= containerCenter && pageRect.bottom >= containerCenter) {
          currentPage = i + 1;
          break;
        }
      }
    }, 100);
  });

  /* Handle window resize to maintain optimal rendering quality */
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      renderedPages.clear();
      for (let i = 1; i <= Math.min(3, pdfDoc.numPages); i++) {
        renderPage(i);
      }
      setTimeout(() => {
        for (let i = 4; i <= pdfDoc.numPages; i++) {
          renderPage(i);
        }
      }, 10);
    }, 5);
  });
</script>

</body>
</html>
